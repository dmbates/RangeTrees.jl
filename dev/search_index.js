var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = RangeTrees","category":"page"},{"location":"#RangeTrees","page":"Home","title":"RangeTrees","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for RangeTrees.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [RangeTrees]","category":"page"},{"location":"#RangeTrees.RangeNode","page":"Home","title":"RangeTrees.RangeNode","text":"RangeNode{T}\n\nThe element type of the vector in the nodes field of a RangeTree.\n\nThe value of a RangeNode{T} is the UnitRange{T} in its intvl field. The left and right fields are the indices of the children of this node (values of 0 imply no child on that side).\n\nThe maxlast field is the maximum value of last(n.intvl) for any node n in the right subtree.  This is the \"augmentation\" in an augmented interval tree that allows for efficient intersection of an interval with all the nodes of a RangeTree.\n\n\n\n\n\n","category":"type"},{"location":"#RangeTrees.RangeTree","page":"Home","title":"RangeTrees.RangeTree","text":"RangeTree\n\nAn augmented, balanced, binary interval tree of intervals of integers represented as a UnitRange.\n\nThe nodes field, a vector of RangeNodes, is the tree. The root node of a RangeTree has index midrange(eachindex(nodes)).\n\nA RangeTree is usually constructed from a Vector{UnitRange{<:Integer}}. It is designed to allow for fast intersection of another UnitRange{<:Integer} with the values of all the nodes in the tree.\n\n```jldoctest julia> rt = RangeTree([0:0, 3:40, 10:14, 20:35, 29:98]); # example from Wikipedia page\n\njulia> intersect(40:59, rt) 2-element Vector{UnitRange{Int64}}:  40:40  40:59 ````\n\n\n\n\n\n","category":"type"},{"location":"#Base.intersect!-Union{Tuple{T}, Tuple{Array{UnitRange{T}, 1}, UnitRange{T}, RangeTree{T}, Integer}} where T","page":"Home","title":"Base.intersect!","text":"intersect!(result::AbstractVector{UnitRange}, target::UnitRange, rt::RangeTree, idx::Integer)\n\nRecursively intersect target with the intervals in the subtree of rt[idx].\n\nNon-empty intersections are pushed onto result in the same order as the intersecting nodes appear in the tree. Storing maxlast allows for the pre-order depth-first search to be truncated when a node's maxlast is less than first(target).  Because the nodes are in non-decreasing order of first(intvl) the right subtree can be skipped when last(target) < first(intvl).\n\n\n\n\n\n","category":"method"},{"location":"#RangeTrees._addchildren!-Union{Tuple{T}, Tuple{Array{RangeNode{T}, 1}, AbstractUnitRange}} where T","page":"Home","title":"RangeTrees._addchildren!","text":"_addchildren!(v::Vector{RangeNode{T}}, inds::UnitRange) where T\n\nInternal utility to recursively re-write the left, right, and maxlast fields in v[inds] so as to form an augmented, balanced, binary interval tree.\n\n\n\n\n\n","category":"method"},{"location":"#RangeTrees.midrange-Union{Tuple{AbstractUnitRange{T}}, Tuple{T}} where T<:Integer","page":"Home","title":"RangeTrees.midrange","text":"midrange(rng::AbstractUnitRange{T}) where {T<:Integer}\n\nReturn the median of rng, rounding up when length(rng) is even.\n\n\n\n\n\n","category":"method"}]
}
