var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = RangeTrees","category":"page"},{"location":"#RangeTrees","page":"Home","title":"RangeTrees","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for RangeTrees.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [RangeTrees]","category":"page"},{"location":"#RangeTrees.RangeNode","page":"Home","title":"RangeTrees.RangeNode","text":"RangeNode{T}\n\nThe element type of the vector in the nodes field of a RangeTree.\n\nThe value of a RangeNode{T} is the UnitRange{T} in its intvl field. The left and right fields are the indices of the children of this node (values of 0 imply no child on that side).\n\nThe maxlast field is the maximum value of last(n.intvl) for any node n in the right subtree.  This is the \"augmentation\" in an augmented interval tree that allows for efficient intersection of an interval with all the nodes of a RangeTree.\n\n\n\n\n\n","category":"type"},{"location":"#RangeTrees.RangeTree","page":"Home","title":"RangeTrees.RangeTree","text":"RangeTree\n\nAn augmented, balanced, binary interval tree of intervals of integers represented as a UnitRange.\n\nThe nodes field, a vector of RangeNodes, is the tree. The root node of a RangeTree rt is rt.nodes[rt.rootind]. The rootind field should always be midrange(UnitRange(eachindex(nodes))).\n\nA RangeTree is usually constructed from a Vector{UnitRange{<:Integer}}.  It is designed to allow for fast intersection of another UnitRange{<:Integer with the values of all the nodes in the tree.\n\n```jldoctest julia> rt = RangeTree([0:0, 3:40, 10:14, 20:35, 29:98]); # example from Wikipedia page\n\njulia> intersect(40:59, rt) 2-element Vector{UnitRange{Int64}}:  40:40  40:59 ````\n\n\n\n\n\n","category":"type"},{"location":"#RangeTrees._addchildren!-Union{Tuple{T}, Tuple{Array{RangeNode{T}, 1}, UnitRange}} where T","page":"Home","title":"RangeTrees._addchildren!","text":"_addchildren!(v::Vector{RangeNode{T}}, inds::UnitRange) where T\n\nInternal utility to recursively re-write the left, right, and maxlast fields in v[inds] so as to form an augmented, balanced, binary interval tree.\n\n\n\n\n\n","category":"method"},{"location":"#RangeTrees.intersect!-Union{Tuple{T}, Tuple{Array{UnitRange{T}, 1}, UnitRange{T}, RangeTree{T}, Integer}} where T","page":"Home","title":"RangeTrees.intersect!","text":"intersect!(result::AbstractVector{UnitRange}, target::UnitRange, rt::RangeTree, index)\n\nRecursively intersect target with the intervals in the subtree of rt.nodes[index]. Non-empty intersections are pushed onto result in sorted order.\n\n\n\n\n\n","category":"method"},{"location":"#RangeTrees.midrange-Union{Tuple{UnitRange{T}}, Tuple{T}} where T","page":"Home","title":"RangeTrees.midrange","text":"midrange(rng::UnitRange{T})::T\n\nReturn the median of rng, rounding up when length(rng) is even.\n\n\n\n\n\n","category":"method"}]
}
